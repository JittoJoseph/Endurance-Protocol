"use client";

import { useRef, useEffect, Suspense, memo, useState } from "react";
import { Canvas, useFrame, useThree } from "@react-three/fiber";
import { OrbitControls, Stars } from "@react-three/drei";
import { EarthMaterial } from "./EarthMaterial";
import Asteroid from "./Asteroid";
import ImpactMarker from "./ImpactMarker";
import ImpactEffects from "./ImpactEffects";
import { vector3ToLatLon, latLonToVector3 } from "@/lib/physics";
import { useSceneAnimation } from "@/hooks/useSceneAnimation";
import * as THREE from "three";

// Define props type
interface EarthSceneProps {
  onGlobeClick: (lat: number, lon: number) => void;
  impactPoint: { lat: number; lon: number } | null;
  asteroidInFlight: boolean;
  asteroidSize: number; // diameter in meters
  onImpactComplete: () => void | Promise<void>;
  selectedAsteroid?: boolean; // Whether an asteroid is selected
  cameraPreset?: string; // Camera preset for transitions
}

// Click handler component
function EarthClickHandler({
  onGlobeClick,
  earthRadius = 2,
}: {
  onGlobeClick: (lat: number, lon: number) => void;
  earthRadius?: number;
}) {
  const { camera, raycaster, scene } = useThree();

  const handleClick = (event: MouseEvent) => {
    // Convert mouse position to normalized device coordinates (-1 to +1)
    const canvas = event.target as HTMLCanvasElement;
    const rect = canvas.getBoundingClientRect();
    const x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
    const y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

    // Update raycaster
    raycaster.setFromCamera(new THREE.Vector2(x, y), camera);

    // Find Earth mesh in scene
    const earthMesh = scene.children.find(
      (child) =>
        child instanceof THREE.Mesh &&
        child.geometry instanceof THREE.SphereGeometry
    );

    if (!earthMesh) return;

    // Raycast to find intersection
    const intersects = raycaster.intersectObject(earthMesh, false);

    if (intersects.length > 0) {
      const point = intersects[0].point;
      const { lat, lon } = vector3ToLatLon(
        point.x,
        point.y,
        point.z,
        earthRadius
      );
      onGlobeClick(lat, lon);
    }
  };

  useEffect(() => {
    const canvas = document.querySelector("canvas");
    if (canvas) {
      canvas.addEventListener("click", handleClick as any);
      return () => canvas.removeEventListener("click", handleClick as any);
    }
  }, [onGlobeClick]);

  return null;
}

const Earth = memo(
  ({
    isDragging,
    shouldPauseCycle,
    earthMeshRef,
    cloudMeshRef,
  }: {
    isDragging: React.MutableRefObject<boolean>;
    shouldPauseCycle: () => boolean;
    earthMeshRef: React.MutableRefObject<THREE.Mesh | null>;
    cloudMeshRef: React.MutableRefObject<THREE.Mesh | null>;
  }) => {
    const earthGroupRef = useRef<THREE.Group>(null);

    const { earthMaterial, cloudsMap } = EarthMaterial();

    useFrame((_, delta) => {
      // Only auto-rotate if not dragging AND not paused (no point selected)
      if (!isDragging.current && !shouldPauseCycle()) {
        if (earthMeshRef.current) {
          earthMeshRef.current.rotation.y += delta * 0.1;
        }
        if (cloudMeshRef.current) {
          cloudMeshRef.current.rotation.y += delta * 0.12;
        }
      }
    });

    return (
      <group ref={earthGroupRef}>
        {/* Sunlight that follows Earth when dragging - angled for slanted terminator */}
        <directionalLight
          intensity={2.5}
          position={[10, 3, 0]}
          color="#ffffff"
        />

        {/* Earth */}
        <mesh ref={earthMeshRef}>
          <sphereGeometry args={[2, 64, 64]} />
          {earthMaterial}
        </mesh>

        {/* Clouds */}
        <mesh ref={cloudMeshRef}>
          <sphereGeometry args={[2.01, 64, 64]} />
          <meshBasicMaterial
            map={cloudsMap}
            transparent
            opacity={0.2}
            depthWrite={false}
            side={THREE.DoubleSide}
          />
        </mesh>

        {/* Atmospheric glow (Fresnel effect) */}
        <mesh scale={1.04}>
          <sphereGeometry args={[2.02, 32, 32]} />
          <shaderMaterial
            transparent
            side={THREE.BackSide}
            blending={THREE.AdditiveBlending}
            depthWrite={false}
            uniforms={{
              glowColor: { value: new THREE.Color(0x00aaff) },
              coefficient: { value: 0.5 },
              power: { value: 3.5 },
            }}
            vertexShader={`
              varying vec3 vNormal;
              varying vec3 vPositionNormal;
              
              void main() {
                vNormal = normalize(normalMatrix * normal);
                vPositionNormal = normalize((modelViewMatrix * vec4(position, 1.0)).xyz);
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
              }
            `}
            fragmentShader={`
              uniform vec3 glowColor;
              uniform float coefficient;
              uniform float power;
              
              varying vec3 vNormal;
              varying vec3 vPositionNormal;
              
              void main() {
                float intensity = pow(coefficient + dot(vNormal, vPositionNormal), power);
                gl_FragColor = vec4(glowColor, intensity * 0.5);
              }
            `}
          />
        </mesh>
      </group>
    );
  }
);

Earth.displayName = "Earth";

// Scene controller - manages animations and interactions
function SceneController({
  onGlobeClick,
  impactPoint,
  selectedAsteroid,
  cameraPreset,
  earthMeshRef,
  cloudMeshRef,
}: {
  onGlobeClick: (lat: number, lon: number) => void;
  impactPoint: { lat: number; lon: number } | null;
  selectedAsteroid: boolean;
  cameraPreset?: string;
  earthMeshRef: React.MutableRefObject<THREE.Mesh | null>;
  cloudMeshRef: React.MutableRefObject<THREE.Mesh | null>;
}) {
  const { camera, gl } = useThree();
  const controlsRef = useRef<any>(null);
  const {
    animateCameraToPreset,
    rotateEarthToPoint,
    animateCameraAndEarthToPoint,
    setPaused,
    update,
    shouldPauseCycle,
  } = useSceneAnimation();

  // Update animations every frame
  useFrame(() => {
    update();
  });

  // Handle impact point selection
  useEffect(() => {
    if (impactPoint && earthMeshRef.current && controlsRef.current) {
      // Animate camera and earth to show the selected point
      animateCameraAndEarthToPoint(
        impactPoint.lat,
        impactPoint.lon,
        earthMeshRef.current,
        cloudMeshRef.current,
        camera,
        controlsRef.current,
        cameraPreset || "impact",
        () => {
          // Keep Earth paused after animation completes
          setPaused(true);
        }
      );
    }
  }, [
    impactPoint,
    camera,
    cameraPreset,
    animateCameraAndEarthToPoint,
    earthMeshRef,
    cloudMeshRef,
    setPaused,
  ]);

  // Handle asteroid selection (pause cycle but don't rotate)
  useEffect(() => {
    if (selectedAsteroid && !impactPoint) {
      setPaused(true);
    } else if (!selectedAsteroid && !impactPoint) {
      setPaused(false);
    }
  }, [selectedAsteroid, impactPoint, setPaused]);

  // Handle camera preset changes (only when no impact point selected)
  useEffect(() => {
    if (cameraPreset && controlsRef.current && !impactPoint) {
      animateCameraToPreset(cameraPreset, camera, controlsRef.current);
    }
  }, [cameraPreset, camera, animateCameraToPreset, impactPoint]);

  return (
    <OrbitControls
      ref={controlsRef}
      enablePan={false}
      enableZoom={false}
      minPolarAngle={Math.PI / 2}
      maxPolarAngle={Math.PI / 2}
      autoRotate={false}
      enabled={!shouldPauseCycle()} // Disable manual controls during animations
    />
  );
}

// Asteroid flight animation component
function AsteroidFlight({
  targetLat,
  targetLon,
  asteroidSize,
  onImpactComplete,
}: {
  targetLat: number;
  targetLon: number;
  asteroidSize: number;
  onImpactComplete: () => void;
}) {
  const [progress, setProgress] = useState(0);
  const [showImpact, setShowImpact] = useState(false);

  // Define Bezier curve path
  const startPos = new THREE.Vector3(8, 6, 8); // Far away position
  const targetPos = new THREE.Vector3(
    ...latLonToVector3(targetLat, targetLon, 2)
  );

  // Control points for Bezier curve
  const midPoint1 = startPos
    .clone()
    .lerp(targetPos, 0.33)
    .add(new THREE.Vector3(2, 3, 2));
  const midPoint2 = startPos
    .clone()
    .lerp(targetPos, 0.67)
    .add(new THREE.Vector3(1, 1, 1));

  const curve = new THREE.CubicBezierCurve3(
    startPos,
    midPoint1,
    midPoint2,
    targetPos
  );

  useFrame((_, delta) => {
    if (progress < 1) {
      setProgress((p) => Math.min(p + delta * 0.3, 1)); // 3-4 second flight
    } else if (!showImpact) {
      setShowImpact(true);
    }
  });

  const currentPos = curve.getPoint(progress);

  return (
    <>
      {/* Flying asteroid */}
      {progress < 1 && (
        <Asteroid
          position={[currentPos.x, currentPos.y, currentPos.z]}
          size={asteroidSize}
          visible={true}
        />
      )}

      {/* Impact effects */}
      {showImpact && (
        <ImpactEffects
          lat={targetLat}
          lon={targetLon}
          radius={2}
          onComplete={onImpactComplete}
        />
      )}
    </>
  );
}

export default function EarthScene({
  onGlobeClick,
  impactPoint,
  asteroidInFlight,
  asteroidSize,
  onImpactComplete,
  selectedAsteroid = false,
  cameraPreset,
}: EarthSceneProps) {
  const canvasRef = useRef<HTMLDivElement>(null);
  const isDragging = useRef(false);
  const earthMeshRef = useRef<THREE.Mesh | null>(null);
  const cloudMeshRef = useRef<THREE.Mesh | null>(null);
  const { shouldPauseCycle } = useSceneAnimation();

  // Handle WebGL context loss
  useEffect(() => {
    const handleContextLost = (event: Event) => {
      event.preventDefault();
      console.warn("⚠️ WebGL context lost - Attempting recovery...");
    };
    const handleContextRestored = () => {
      console.log("✅ WebGL context restored successfully");
    };

    const canvas = canvasRef.current?.querySelector("canvas");
    if (canvas) {
      canvas.addEventListener("webglcontextlost", handleContextLost, false);
      canvas.addEventListener(
        "webglcontextrestored",
        handleContextRestored,
        false
      );

      return () => {
        canvas.removeEventListener("webglcontextlost", handleContextLost);
        canvas.removeEventListener(
          "webglcontextrestored",
          handleContextRestored
        );
      };
    }
  }, []);

  // Debug logging (optional)
  useEffect(() => {
    if (process.env.NODE_ENV === "development") {
      console.log("🌍 Earth Scene mounted - textures will persist during HMR");
    }
  }, []);

  return (
    <div ref={canvasRef} className="w-full h-full">
      <Canvas
        camera={{ position: [5, 0, 5], fov: 45 }}
        gl={{
          preserveDrawingBuffer: true,
          antialias: true,
          powerPreference: "high-performance",
          alpha: false,
        }}
        dpr={[1, 2]}
        frameloop="always"
      >
        {/* Fixed sunlight in world space (the "Sun") */}
        <directionalLight
          intensity={2.5}
          position={[10, 0, 0]} // Sunlight from +X
          color="#ffffff"
        />
        <ambientLight intensity={0.15} />

        {/* Earth */}
        <Suspense fallback={null}>
          <Earth
            isDragging={isDragging}
            shouldPauseCycle={shouldPauseCycle}
            earthMeshRef={earthMeshRef}
            cloudMeshRef={cloudMeshRef}
          />
        </Suspense>

        {/* Scene Controller - manages animations */}
        <SceneController
          onGlobeClick={onGlobeClick}
          impactPoint={impactPoint}
          selectedAsteroid={selectedAsteroid}
          cameraPreset={cameraPreset}
          earthMeshRef={earthMeshRef}
          cloudMeshRef={cloudMeshRef}
        />

        {/* Click detection */}
        <EarthClickHandler onGlobeClick={onGlobeClick} earthRadius={2} />

        {/* Impact marker */}
        {impactPoint && !asteroidInFlight && (
          <ImpactMarker
            lat={impactPoint.lat}
            lon={impactPoint.lon}
            radius={2}
            visible={true}
          />
        )}

        {/* Asteroid flight animation */}
        {asteroidInFlight && impactPoint && (
          <AsteroidFlight
            targetLat={impactPoint.lat}
            targetLon={impactPoint.lon}
            asteroidSize={asteroidSize}
            onImpactComplete={onImpactComplete}
          />
        )}

        {/* Stars */}
        <Stars radius={100} depth={50} count={5000} factor={4} fade />
      </Canvas>
    </div>
  );
}
